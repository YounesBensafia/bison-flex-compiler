Grammaire

    0 $accept: program $end

    1 $@1: ε

    2 program: idf $@1 mc_data declartions_list mc_end mc_code instruction_list mc_end mc_end

    3 $@2: ε

    4 declartions_list: type colon idf $@2 liste_vars declartions_list
    5                 | vector declartions_list
    6                 | constante pvg declartions_list
    7                 | ε

    8 liste_vars: virgule idf liste_vars
    9           | pvg

   10 $@3: ε

   11 vector: MC_VECTOR colon idf left_bracket INTEGER virgule INTEGER colon type $@3 right_bracket pvg

   12 constante: mc_const colon idf eq factor_constante

   13 factor_constante: INTEGER
   14                 | FLOAT
   15                 | STRING
   16                 | CHAR

   17 type: mc_integer
   18     | mc_float
   19     | mc_char
   20     | mc_string

   21 instruction_list: instruction instruction_list
   22                 | ε

   23 instruction: assignment
   24            | read_display
   25            | if_condition
   26            | loop

   27 assignment: idf eq expression pvg

   28 read_display: mc_read PARAO STRING colon arobase idf PARAF pvg
   29             | mc_display PARAO STRING colon idf PARAF pvg

   30 if_condition: mc_if PARAO condition PARAF colon instruction_list else_condition

   31 else_condition: mc_else colon instruction_list mc_end
   32               | mc_end

   33 loop: mc_for PARAO idf colon INTEGER colon INTEGER PARAF instruction_list mc_end

   34 expression: term
   35           | expression sum term
   36           | expression minus term

   37 term: factor
   38     | term mul factor
   39     | term DIV factor

   40 factor: INTEGER
   41       | FLOAT
   42       | CHAR
   43       | STRING
   44       | idf
   45       | PARAO expression PARAF

   46 condition: expression dot mc_ge dot expression
   47          | expression dot mc_le dot expression
   48          | expression dot mc_l dot expression
   49          | expression dot mc_di dot expression
   50          | expression dot mc_not dot expression
   51          | expression dot mc_or dot expression


Terminaux, suivis des règles où ils apparaissent

    $end (0) 0
    error (256)
    mc_end <string> (258) 2 31 32 33
    mc_data <string> (259) 2
    mc_code <string> (260) 2
    MC_VECTOR <string> (261) 11
    mc_const <string> (262) 12
    mc_if (263) 30
    mc_else (264) 31
    mc_for (265) 33
    mc_or (266) 51
    mc_not (267) 50
    mc_ge (268) 46
    mc_l (269) 48
    mc_di (270) 49
    mc_le (271) 47
    mc_read (272) 28
    mc_display (273) 29
    idf <string> (274) 2 4 8 11 12 27 28 29 33 44
    INTEGER <entier> (275) 11 13 33 40
    FLOAT <real> (276) 14 41
    CHAR <string> (277) 16 42
    STRING <string> (278) 15 28 29 43
    pvg <string> (279) 6 9 11 27 28 29
    sum <string> (280) 35
    mul <string> (281) 38
    minus <string> (282) 36
    PARAO <string> (283) 28 29 30 33 45
    PARAF <string> (284) 28 29 30 33 45
    colon <string> (285) 4 11 12 28 29 30 31 33
    dot <string> (286) 46 47 48 49 50 51
    DIV <string> (287) 39
    eq <string> (288) 12 27
    virgule <string> (289) 8 11
    arobase <string> (290) 28
    left_bracket (291) 11
    right_bracket (292) 11
    mc_integer <string> (293) 17
    mc_float <string> (294) 18
    mc_char <string> (295) 19
    mc_string <string> (296) 20


Non-terminaux, suivis des règles où ils apparaissent

    $accept (42)
        à gauche: 0
    program (43)
        à gauche: 2
        à droite: 0
    $@1 (44)
        à gauche: 1
        à droite: 2
    declartions_list (45)
        à gauche: 4 5 6 7
        à droite: 2 4 5 6
    $@2 (46)
        à gauche: 3
        à droite: 4
    liste_vars (47)
        à gauche: 8 9
        à droite: 4 8
    vector (48)
        à gauche: 11
        à droite: 5
    $@3 (49)
        à gauche: 10
        à droite: 11
    constante (50)
        à gauche: 12
        à droite: 6
    factor_constante (51)
        à gauche: 13 14 15 16
        à droite: 12
    type <string> (52)
        à gauche: 17 18 19 20
        à droite: 4 11
    instruction_list (53)
        à gauche: 21 22
        à droite: 2 21 30 31 33
    instruction (54)
        à gauche: 23 24 25 26
        à droite: 21
    assignment (55)
        à gauche: 27
        à droite: 23
    read_display (56)
        à gauche: 28 29
        à droite: 24
    if_condition (57)
        à gauche: 30
        à droite: 25
    else_condition (58)
        à gauche: 31 32
        à droite: 30
    loop (59)
        à gauche: 33
        à droite: 26
    expression (60)
        à gauche: 34 35 36
        à droite: 27 35 36 45 46 47 48 49 50 51
    term (61)
        à gauche: 37 38 39
        à droite: 34 35 36 38 39
    factor (62)
        à gauche: 40 41 42 43 44 45
        à droite: 37 38 39
    condition (63)
        à gauche: 46 47 48 49 50 51
        à droite: 30


État 0

    0 $accept: • program $end

    idf  décalage et aller à l'état 1

    program  aller à l'état 2


État 1

    2 program: idf • $@1 mc_data declartions_list mc_end mc_code instruction_list mc_end mc_end

    $défaut  réduction par utilisation de la règle 1 ($@1)

    $@1  aller à l'état 3


État 2

    0 $accept: program • $end

    $end  décalage et aller à l'état 4


État 3

    2 program: idf $@1 • mc_data declartions_list mc_end mc_code instruction_list mc_end mc_end

    mc_data  décalage et aller à l'état 5


État 4

    0 $accept: program $end •

    $défaut  accepter


État 5

    2 program: idf $@1 mc_data • declartions_list mc_end mc_code instruction_list mc_end mc_end

    MC_VECTOR   décalage et aller à l'état 6
    mc_const    décalage et aller à l'état 7
    mc_integer  décalage et aller à l'état 8
    mc_float    décalage et aller à l'état 9
    mc_char     décalage et aller à l'état 10
    mc_string   décalage et aller à l'état 11

    $défaut  réduction par utilisation de la règle 7 (declartions_list)

    declartions_list  aller à l'état 12
    vector            aller à l'état 13
    constante         aller à l'état 14
    type              aller à l'état 15


État 6

   11 vector: MC_VECTOR • colon idf left_bracket INTEGER virgule INTEGER colon type $@3 right_bracket pvg

    colon  décalage et aller à l'état 16


État 7

   12 constante: mc_const • colon idf eq factor_constante

    colon  décalage et aller à l'état 17


État 8

   17 type: mc_integer •

    $défaut  réduction par utilisation de la règle 17 (type)


État 9

   18 type: mc_float •

    $défaut  réduction par utilisation de la règle 18 (type)


État 10

   19 type: mc_char •

    $défaut  réduction par utilisation de la règle 19 (type)


État 11

   20 type: mc_string •

    $défaut  réduction par utilisation de la règle 20 (type)


État 12

    2 program: idf $@1 mc_data declartions_list • mc_end mc_code instruction_list mc_end mc_end

    mc_end  décalage et aller à l'état 18


État 13

    5 declartions_list: vector • declartions_list

    MC_VECTOR   décalage et aller à l'état 6
    mc_const    décalage et aller à l'état 7
    mc_integer  décalage et aller à l'état 8
    mc_float    décalage et aller à l'état 9
    mc_char     décalage et aller à l'état 10
    mc_string   décalage et aller à l'état 11

    $défaut  réduction par utilisation de la règle 7 (declartions_list)

    declartions_list  aller à l'état 19
    vector            aller à l'état 13
    constante         aller à l'état 14
    type              aller à l'état 15


État 14

    6 declartions_list: constante • pvg declartions_list

    pvg  décalage et aller à l'état 20


État 15

    4 declartions_list: type • colon idf $@2 liste_vars declartions_list

    colon  décalage et aller à l'état 21


État 16

   11 vector: MC_VECTOR colon • idf left_bracket INTEGER virgule INTEGER colon type $@3 right_bracket pvg

    idf  décalage et aller à l'état 22


État 17

   12 constante: mc_const colon • idf eq factor_constante

    idf  décalage et aller à l'état 23


État 18

    2 program: idf $@1 mc_data declartions_list mc_end • mc_code instruction_list mc_end mc_end

    mc_code  décalage et aller à l'état 24


État 19

    5 declartions_list: vector declartions_list •

    $défaut  réduction par utilisation de la règle 5 (declartions_list)


État 20

    6 declartions_list: constante pvg • declartions_list

    MC_VECTOR   décalage et aller à l'état 6
    mc_const    décalage et aller à l'état 7
    mc_integer  décalage et aller à l'état 8
    mc_float    décalage et aller à l'état 9
    mc_char     décalage et aller à l'état 10
    mc_string   décalage et aller à l'état 11

    $défaut  réduction par utilisation de la règle 7 (declartions_list)

    declartions_list  aller à l'état 25
    vector            aller à l'état 13
    constante         aller à l'état 14
    type              aller à l'état 15


État 21

    4 declartions_list: type colon • idf $@2 liste_vars declartions_list

    idf  décalage et aller à l'état 26


État 22

   11 vector: MC_VECTOR colon idf • left_bracket INTEGER virgule INTEGER colon type $@3 right_bracket pvg

    left_bracket  décalage et aller à l'état 27


État 23

   12 constante: mc_const colon idf • eq factor_constante

    eq  décalage et aller à l'état 28


État 24

    2 program: idf $@1 mc_data declartions_list mc_end mc_code • instruction_list mc_end mc_end

    mc_if       décalage et aller à l'état 29
    mc_for      décalage et aller à l'état 30
    mc_read     décalage et aller à l'état 31
    mc_display  décalage et aller à l'état 32
    idf         décalage et aller à l'état 33

    $défaut  réduction par utilisation de la règle 22 (instruction_list)

    instruction_list  aller à l'état 34
    instruction       aller à l'état 35
    assignment        aller à l'état 36
    read_display      aller à l'état 37
    if_condition      aller à l'état 38
    loop              aller à l'état 39


État 25

    6 declartions_list: constante pvg declartions_list •

    $défaut  réduction par utilisation de la règle 6 (declartions_list)


État 26

    4 declartions_list: type colon idf • $@2 liste_vars declartions_list

    $défaut  réduction par utilisation de la règle 3 ($@2)

    $@2  aller à l'état 40


État 27

   11 vector: MC_VECTOR colon idf left_bracket • INTEGER virgule INTEGER colon type $@3 right_bracket pvg

    INTEGER  décalage et aller à l'état 41


État 28

   12 constante: mc_const colon idf eq • factor_constante

    INTEGER  décalage et aller à l'état 42
    FLOAT    décalage et aller à l'état 43
    CHAR     décalage et aller à l'état 44
    STRING   décalage et aller à l'état 45

    factor_constante  aller à l'état 46


État 29

   30 if_condition: mc_if • PARAO condition PARAF colon instruction_list else_condition

    PARAO  décalage et aller à l'état 47


État 30

   33 loop: mc_for • PARAO idf colon INTEGER colon INTEGER PARAF instruction_list mc_end

    PARAO  décalage et aller à l'état 48


État 31

   28 read_display: mc_read • PARAO STRING colon arobase idf PARAF pvg

    PARAO  décalage et aller à l'état 49


État 32

   29 read_display: mc_display • PARAO STRING colon idf PARAF pvg

    PARAO  décalage et aller à l'état 50


État 33

   27 assignment: idf • eq expression pvg

    eq  décalage et aller à l'état 51


État 34

    2 program: idf $@1 mc_data declartions_list mc_end mc_code instruction_list • mc_end mc_end

    mc_end  décalage et aller à l'état 52


État 35

   21 instruction_list: instruction • instruction_list

    mc_if       décalage et aller à l'état 29
    mc_for      décalage et aller à l'état 30
    mc_read     décalage et aller à l'état 31
    mc_display  décalage et aller à l'état 32
    idf         décalage et aller à l'état 33

    $défaut  réduction par utilisation de la règle 22 (instruction_list)

    instruction_list  aller à l'état 53
    instruction       aller à l'état 35
    assignment        aller à l'état 36
    read_display      aller à l'état 37
    if_condition      aller à l'état 38
    loop              aller à l'état 39


État 36

   23 instruction: assignment •

    $défaut  réduction par utilisation de la règle 23 (instruction)


État 37

   24 instruction: read_display •

    $défaut  réduction par utilisation de la règle 24 (instruction)


État 38

   25 instruction: if_condition •

    $défaut  réduction par utilisation de la règle 25 (instruction)


État 39

   26 instruction: loop •

    $défaut  réduction par utilisation de la règle 26 (instruction)


État 40

    4 declartions_list: type colon idf $@2 • liste_vars declartions_list

    pvg      décalage et aller à l'état 54
    virgule  décalage et aller à l'état 55

    liste_vars  aller à l'état 56


État 41

   11 vector: MC_VECTOR colon idf left_bracket INTEGER • virgule INTEGER colon type $@3 right_bracket pvg

    virgule  décalage et aller à l'état 57


État 42

   13 factor_constante: INTEGER •

    $défaut  réduction par utilisation de la règle 13 (factor_constante)


État 43

   14 factor_constante: FLOAT •

    $défaut  réduction par utilisation de la règle 14 (factor_constante)


État 44

   16 factor_constante: CHAR •

    $défaut  réduction par utilisation de la règle 16 (factor_constante)


État 45

   15 factor_constante: STRING •

    $défaut  réduction par utilisation de la règle 15 (factor_constante)


État 46

   12 constante: mc_const colon idf eq factor_constante •

    $défaut  réduction par utilisation de la règle 12 (constante)


État 47

   30 if_condition: mc_if PARAO • condition PARAF colon instruction_list else_condition

    idf      décalage et aller à l'état 58
    INTEGER  décalage et aller à l'état 59
    FLOAT    décalage et aller à l'état 60
    CHAR     décalage et aller à l'état 61
    STRING   décalage et aller à l'état 62
    PARAO    décalage et aller à l'état 63

    expression  aller à l'état 64
    term        aller à l'état 65
    factor      aller à l'état 66
    condition   aller à l'état 67


État 48

   33 loop: mc_for PARAO • idf colon INTEGER colon INTEGER PARAF instruction_list mc_end

    idf  décalage et aller à l'état 68


État 49

   28 read_display: mc_read PARAO • STRING colon arobase idf PARAF pvg

    STRING  décalage et aller à l'état 69


État 50

   29 read_display: mc_display PARAO • STRING colon idf PARAF pvg

    STRING  décalage et aller à l'état 70


État 51

   27 assignment: idf eq • expression pvg

    idf      décalage et aller à l'état 58
    INTEGER  décalage et aller à l'état 59
    FLOAT    décalage et aller à l'état 60
    CHAR     décalage et aller à l'état 61
    STRING   décalage et aller à l'état 62
    PARAO    décalage et aller à l'état 63

    expression  aller à l'état 71
    term        aller à l'état 65
    factor      aller à l'état 66


État 52

    2 program: idf $@1 mc_data declartions_list mc_end mc_code instruction_list mc_end • mc_end

    mc_end  décalage et aller à l'état 72


État 53

   21 instruction_list: instruction instruction_list •

    $défaut  réduction par utilisation de la règle 21 (instruction_list)


État 54

    9 liste_vars: pvg •

    $défaut  réduction par utilisation de la règle 9 (liste_vars)


État 55

    8 liste_vars: virgule • idf liste_vars

    idf  décalage et aller à l'état 73


État 56

    4 declartions_list: type colon idf $@2 liste_vars • declartions_list

    MC_VECTOR   décalage et aller à l'état 6
    mc_const    décalage et aller à l'état 7
    mc_integer  décalage et aller à l'état 8
    mc_float    décalage et aller à l'état 9
    mc_char     décalage et aller à l'état 10
    mc_string   décalage et aller à l'état 11

    $défaut  réduction par utilisation de la règle 7 (declartions_list)

    declartions_list  aller à l'état 74
    vector            aller à l'état 13
    constante         aller à l'état 14
    type              aller à l'état 15


État 57

   11 vector: MC_VECTOR colon idf left_bracket INTEGER virgule • INTEGER colon type $@3 right_bracket pvg

    INTEGER  décalage et aller à l'état 75


État 58

   44 factor: idf •

    $défaut  réduction par utilisation de la règle 44 (factor)


État 59

   40 factor: INTEGER •

    $défaut  réduction par utilisation de la règle 40 (factor)


État 60

   41 factor: FLOAT •

    $défaut  réduction par utilisation de la règle 41 (factor)


État 61

   42 factor: CHAR •

    $défaut  réduction par utilisation de la règle 42 (factor)


État 62

   43 factor: STRING •

    $défaut  réduction par utilisation de la règle 43 (factor)


État 63

   45 factor: PARAO • expression PARAF

    idf      décalage et aller à l'état 58
    INTEGER  décalage et aller à l'état 59
    FLOAT    décalage et aller à l'état 60
    CHAR     décalage et aller à l'état 61
    STRING   décalage et aller à l'état 62
    PARAO    décalage et aller à l'état 63

    expression  aller à l'état 76
    term        aller à l'état 65
    factor      aller à l'état 66


État 64

   35 expression: expression • sum term
   36           | expression • minus term
   46 condition: expression • dot mc_ge dot expression
   47          | expression • dot mc_le dot expression
   48          | expression • dot mc_l dot expression
   49          | expression • dot mc_di dot expression
   50          | expression • dot mc_not dot expression
   51          | expression • dot mc_or dot expression

    sum    décalage et aller à l'état 77
    minus  décalage et aller à l'état 78
    dot    décalage et aller à l'état 79


État 65

   34 expression: term •
   38 term: term • mul factor
   39     | term • DIV factor

    mul  décalage et aller à l'état 80
    DIV  décalage et aller à l'état 81

    $défaut  réduction par utilisation de la règle 34 (expression)


État 66

   37 term: factor •

    $défaut  réduction par utilisation de la règle 37 (term)


État 67

   30 if_condition: mc_if PARAO condition • PARAF colon instruction_list else_condition

    PARAF  décalage et aller à l'état 82


État 68

   33 loop: mc_for PARAO idf • colon INTEGER colon INTEGER PARAF instruction_list mc_end

    colon  décalage et aller à l'état 83


État 69

   28 read_display: mc_read PARAO STRING • colon arobase idf PARAF pvg

    colon  décalage et aller à l'état 84


État 70

   29 read_display: mc_display PARAO STRING • colon idf PARAF pvg

    colon  décalage et aller à l'état 85


État 71

   27 assignment: idf eq expression • pvg
   35 expression: expression • sum term
   36           | expression • minus term

    pvg    décalage et aller à l'état 86
    sum    décalage et aller à l'état 77
    minus  décalage et aller à l'état 78


État 72

    2 program: idf $@1 mc_data declartions_list mc_end mc_code instruction_list mc_end mc_end •

    $défaut  réduction par utilisation de la règle 2 (program)


État 73

    8 liste_vars: virgule idf • liste_vars

    pvg      décalage et aller à l'état 54
    virgule  décalage et aller à l'état 55

    liste_vars  aller à l'état 87


État 74

    4 declartions_list: type colon idf $@2 liste_vars declartions_list •

    $défaut  réduction par utilisation de la règle 4 (declartions_list)


État 75

   11 vector: MC_VECTOR colon idf left_bracket INTEGER virgule INTEGER • colon type $@3 right_bracket pvg

    colon  décalage et aller à l'état 88


État 76

   35 expression: expression • sum term
   36           | expression • minus term
   45 factor: PARAO expression • PARAF

    sum    décalage et aller à l'état 77
    minus  décalage et aller à l'état 78
    PARAF  décalage et aller à l'état 89


État 77

   35 expression: expression sum • term

    idf      décalage et aller à l'état 58
    INTEGER  décalage et aller à l'état 59
    FLOAT    décalage et aller à l'état 60
    CHAR     décalage et aller à l'état 61
    STRING   décalage et aller à l'état 62
    PARAO    décalage et aller à l'état 63

    term    aller à l'état 90
    factor  aller à l'état 66


État 78

   36 expression: expression minus • term

    idf      décalage et aller à l'état 58
    INTEGER  décalage et aller à l'état 59
    FLOAT    décalage et aller à l'état 60
    CHAR     décalage et aller à l'état 61
    STRING   décalage et aller à l'état 62
    PARAO    décalage et aller à l'état 63

    term    aller à l'état 91
    factor  aller à l'état 66


État 79

   46 condition: expression dot • mc_ge dot expression
   47          | expression dot • mc_le dot expression
   48          | expression dot • mc_l dot expression
   49          | expression dot • mc_di dot expression
   50          | expression dot • mc_not dot expression
   51          | expression dot • mc_or dot expression

    mc_or   décalage et aller à l'état 92
    mc_not  décalage et aller à l'état 93
    mc_ge   décalage et aller à l'état 94
    mc_l    décalage et aller à l'état 95
    mc_di   décalage et aller à l'état 96
    mc_le   décalage et aller à l'état 97


État 80

   38 term: term mul • factor

    idf      décalage et aller à l'état 58
    INTEGER  décalage et aller à l'état 59
    FLOAT    décalage et aller à l'état 60
    CHAR     décalage et aller à l'état 61
    STRING   décalage et aller à l'état 62
    PARAO    décalage et aller à l'état 63

    factor  aller à l'état 98


État 81

   39 term: term DIV • factor

    idf      décalage et aller à l'état 58
    INTEGER  décalage et aller à l'état 59
    FLOAT    décalage et aller à l'état 60
    CHAR     décalage et aller à l'état 61
    STRING   décalage et aller à l'état 62
    PARAO    décalage et aller à l'état 63

    factor  aller à l'état 99


État 82

   30 if_condition: mc_if PARAO condition PARAF • colon instruction_list else_condition

    colon  décalage et aller à l'état 100


État 83

   33 loop: mc_for PARAO idf colon • INTEGER colon INTEGER PARAF instruction_list mc_end

    INTEGER  décalage et aller à l'état 101


État 84

   28 read_display: mc_read PARAO STRING colon • arobase idf PARAF pvg

    arobase  décalage et aller à l'état 102


État 85

   29 read_display: mc_display PARAO STRING colon • idf PARAF pvg

    idf  décalage et aller à l'état 103


État 86

   27 assignment: idf eq expression pvg •

    $défaut  réduction par utilisation de la règle 27 (assignment)


État 87

    8 liste_vars: virgule idf liste_vars •

    $défaut  réduction par utilisation de la règle 8 (liste_vars)


État 88

   11 vector: MC_VECTOR colon idf left_bracket INTEGER virgule INTEGER colon • type $@3 right_bracket pvg

    mc_integer  décalage et aller à l'état 8
    mc_float    décalage et aller à l'état 9
    mc_char     décalage et aller à l'état 10
    mc_string   décalage et aller à l'état 11

    type  aller à l'état 104


État 89

   45 factor: PARAO expression PARAF •

    $défaut  réduction par utilisation de la règle 45 (factor)


État 90

   35 expression: expression sum term •
   38 term: term • mul factor
   39     | term • DIV factor

    mul  décalage et aller à l'état 80
    DIV  décalage et aller à l'état 81

    $défaut  réduction par utilisation de la règle 35 (expression)


État 91

   36 expression: expression minus term •
   38 term: term • mul factor
   39     | term • DIV factor

    mul  décalage et aller à l'état 80
    DIV  décalage et aller à l'état 81

    $défaut  réduction par utilisation de la règle 36 (expression)


État 92

   51 condition: expression dot mc_or • dot expression

    dot  décalage et aller à l'état 105


État 93

   50 condition: expression dot mc_not • dot expression

    dot  décalage et aller à l'état 106


État 94

   46 condition: expression dot mc_ge • dot expression

    dot  décalage et aller à l'état 107


État 95

   48 condition: expression dot mc_l • dot expression

    dot  décalage et aller à l'état 108


État 96

   49 condition: expression dot mc_di • dot expression

    dot  décalage et aller à l'état 109


État 97

   47 condition: expression dot mc_le • dot expression

    dot  décalage et aller à l'état 110


État 98

   38 term: term mul factor •

    $défaut  réduction par utilisation de la règle 38 (term)


État 99

   39 term: term DIV factor •

    $défaut  réduction par utilisation de la règle 39 (term)


État 100

   30 if_condition: mc_if PARAO condition PARAF colon • instruction_list else_condition

    mc_if       décalage et aller à l'état 29
    mc_for      décalage et aller à l'état 30
    mc_read     décalage et aller à l'état 31
    mc_display  décalage et aller à l'état 32
    idf         décalage et aller à l'état 33

    $défaut  réduction par utilisation de la règle 22 (instruction_list)

    instruction_list  aller à l'état 111
    instruction       aller à l'état 35
    assignment        aller à l'état 36
    read_display      aller à l'état 37
    if_condition      aller à l'état 38
    loop              aller à l'état 39


État 101

   33 loop: mc_for PARAO idf colon INTEGER • colon INTEGER PARAF instruction_list mc_end

    colon  décalage et aller à l'état 112


État 102

   28 read_display: mc_read PARAO STRING colon arobase • idf PARAF pvg

    idf  décalage et aller à l'état 113


État 103

   29 read_display: mc_display PARAO STRING colon idf • PARAF pvg

    PARAF  décalage et aller à l'état 114


État 104

   11 vector: MC_VECTOR colon idf left_bracket INTEGER virgule INTEGER colon type • $@3 right_bracket pvg

    $défaut  réduction par utilisation de la règle 10 ($@3)

    $@3  aller à l'état 115


État 105

   51 condition: expression dot mc_or dot • expression

    idf      décalage et aller à l'état 58
    INTEGER  décalage et aller à l'état 59
    FLOAT    décalage et aller à l'état 60
    CHAR     décalage et aller à l'état 61
    STRING   décalage et aller à l'état 62
    PARAO    décalage et aller à l'état 63

    expression  aller à l'état 116
    term        aller à l'état 65
    factor      aller à l'état 66


État 106

   50 condition: expression dot mc_not dot • expression

    idf      décalage et aller à l'état 58
    INTEGER  décalage et aller à l'état 59
    FLOAT    décalage et aller à l'état 60
    CHAR     décalage et aller à l'état 61
    STRING   décalage et aller à l'état 62
    PARAO    décalage et aller à l'état 63

    expression  aller à l'état 117
    term        aller à l'état 65
    factor      aller à l'état 66


État 107

   46 condition: expression dot mc_ge dot • expression

    idf      décalage et aller à l'état 58
    INTEGER  décalage et aller à l'état 59
    FLOAT    décalage et aller à l'état 60
    CHAR     décalage et aller à l'état 61
    STRING   décalage et aller à l'état 62
    PARAO    décalage et aller à l'état 63

    expression  aller à l'état 118
    term        aller à l'état 65
    factor      aller à l'état 66


État 108

   48 condition: expression dot mc_l dot • expression

    idf      décalage et aller à l'état 58
    INTEGER  décalage et aller à l'état 59
    FLOAT    décalage et aller à l'état 60
    CHAR     décalage et aller à l'état 61
    STRING   décalage et aller à l'état 62
    PARAO    décalage et aller à l'état 63

    expression  aller à l'état 119
    term        aller à l'état 65
    factor      aller à l'état 66


État 109

   49 condition: expression dot mc_di dot • expression

    idf      décalage et aller à l'état 58
    INTEGER  décalage et aller à l'état 59
    FLOAT    décalage et aller à l'état 60
    CHAR     décalage et aller à l'état 61
    STRING   décalage et aller à l'état 62
    PARAO    décalage et aller à l'état 63

    expression  aller à l'état 120
    term        aller à l'état 65
    factor      aller à l'état 66


État 110

   47 condition: expression dot mc_le dot • expression

    idf      décalage et aller à l'état 58
    INTEGER  décalage et aller à l'état 59
    FLOAT    décalage et aller à l'état 60
    CHAR     décalage et aller à l'état 61
    STRING   décalage et aller à l'état 62
    PARAO    décalage et aller à l'état 63

    expression  aller à l'état 121
    term        aller à l'état 65
    factor      aller à l'état 66


État 111

   30 if_condition: mc_if PARAO condition PARAF colon instruction_list • else_condition

    mc_end   décalage et aller à l'état 122
    mc_else  décalage et aller à l'état 123

    else_condition  aller à l'état 124


État 112

   33 loop: mc_for PARAO idf colon INTEGER colon • INTEGER PARAF instruction_list mc_end

    INTEGER  décalage et aller à l'état 125


État 113

   28 read_display: mc_read PARAO STRING colon arobase idf • PARAF pvg

    PARAF  décalage et aller à l'état 126


État 114

   29 read_display: mc_display PARAO STRING colon idf PARAF • pvg

    pvg  décalage et aller à l'état 127


État 115

   11 vector: MC_VECTOR colon idf left_bracket INTEGER virgule INTEGER colon type $@3 • right_bracket pvg

    right_bracket  décalage et aller à l'état 128


État 116

   35 expression: expression • sum term
   36           | expression • minus term
   51 condition: expression dot mc_or dot expression •

    sum    décalage et aller à l'état 77
    minus  décalage et aller à l'état 78

    $défaut  réduction par utilisation de la règle 51 (condition)


État 117

   35 expression: expression • sum term
   36           | expression • minus term
   50 condition: expression dot mc_not dot expression •

    sum    décalage et aller à l'état 77
    minus  décalage et aller à l'état 78

    $défaut  réduction par utilisation de la règle 50 (condition)


État 118

   35 expression: expression • sum term
   36           | expression • minus term
   46 condition: expression dot mc_ge dot expression •

    sum    décalage et aller à l'état 77
    minus  décalage et aller à l'état 78

    $défaut  réduction par utilisation de la règle 46 (condition)


État 119

   35 expression: expression • sum term
   36           | expression • minus term
   48 condition: expression dot mc_l dot expression •

    sum    décalage et aller à l'état 77
    minus  décalage et aller à l'état 78

    $défaut  réduction par utilisation de la règle 48 (condition)


État 120

   35 expression: expression • sum term
   36           | expression • minus term
   49 condition: expression dot mc_di dot expression •

    sum    décalage et aller à l'état 77
    minus  décalage et aller à l'état 78

    $défaut  réduction par utilisation de la règle 49 (condition)


État 121

   35 expression: expression • sum term
   36           | expression • minus term
   47 condition: expression dot mc_le dot expression •

    sum    décalage et aller à l'état 77
    minus  décalage et aller à l'état 78

    $défaut  réduction par utilisation de la règle 47 (condition)


État 122

   32 else_condition: mc_end •

    $défaut  réduction par utilisation de la règle 32 (else_condition)


État 123

   31 else_condition: mc_else • colon instruction_list mc_end

    colon  décalage et aller à l'état 129


État 124

   30 if_condition: mc_if PARAO condition PARAF colon instruction_list else_condition •

    $défaut  réduction par utilisation de la règle 30 (if_condition)


État 125

   33 loop: mc_for PARAO idf colon INTEGER colon INTEGER • PARAF instruction_list mc_end

    PARAF  décalage et aller à l'état 130


État 126

   28 read_display: mc_read PARAO STRING colon arobase idf PARAF • pvg

    pvg  décalage et aller à l'état 131


État 127

   29 read_display: mc_display PARAO STRING colon idf PARAF pvg •

    $défaut  réduction par utilisation de la règle 29 (read_display)


État 128

   11 vector: MC_VECTOR colon idf left_bracket INTEGER virgule INTEGER colon type $@3 right_bracket • pvg

    pvg  décalage et aller à l'état 132


État 129

   31 else_condition: mc_else colon • instruction_list mc_end

    mc_if       décalage et aller à l'état 29
    mc_for      décalage et aller à l'état 30
    mc_read     décalage et aller à l'état 31
    mc_display  décalage et aller à l'état 32
    idf         décalage et aller à l'état 33

    $défaut  réduction par utilisation de la règle 22 (instruction_list)

    instruction_list  aller à l'état 133
    instruction       aller à l'état 35
    assignment        aller à l'état 36
    read_display      aller à l'état 37
    if_condition      aller à l'état 38
    loop              aller à l'état 39


État 130

   33 loop: mc_for PARAO idf colon INTEGER colon INTEGER PARAF • instruction_list mc_end

    mc_if       décalage et aller à l'état 29
    mc_for      décalage et aller à l'état 30
    mc_read     décalage et aller à l'état 31
    mc_display  décalage et aller à l'état 32
    idf         décalage et aller à l'état 33

    $défaut  réduction par utilisation de la règle 22 (instruction_list)

    instruction_list  aller à l'état 134
    instruction       aller à l'état 35
    assignment        aller à l'état 36
    read_display      aller à l'état 37
    if_condition      aller à l'état 38
    loop              aller à l'état 39


État 131

   28 read_display: mc_read PARAO STRING colon arobase idf PARAF pvg •

    $défaut  réduction par utilisation de la règle 28 (read_display)


État 132

   11 vector: MC_VECTOR colon idf left_bracket INTEGER virgule INTEGER colon type $@3 right_bracket pvg •

    $défaut  réduction par utilisation de la règle 11 (vector)


État 133

   31 else_condition: mc_else colon instruction_list • mc_end

    mc_end  décalage et aller à l'état 135


État 134

   33 loop: mc_for PARAO idf colon INTEGER colon INTEGER PARAF instruction_list • mc_end

    mc_end  décalage et aller à l'état 136


État 135

   31 else_condition: mc_else colon instruction_list mc_end •

    $défaut  réduction par utilisation de la règle 31 (else_condition)


État 136

   33 loop: mc_for PARAO idf colon INTEGER colon INTEGER PARAF instruction_list mc_end •

    $défaut  réduction par utilisation de la règle 33 (loop)
